{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/navbar.jsx","Algorithms/dijkstra.js","Algorithms/Astar.js","Algorithms/recursiveDivision.js","Algorithms/verticalMaze.js","Algorithms/DFS.js","Algorithms/BFS.js","PathfindingVisualizer/PathfindingVisualizer.jsx","Algorithms/randomMaze.js","App.js","reportWebVitals.js","index.js"],"names":["Node","nextProps","nextState","this","props","isWall","col","row","nodeSize","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","nodeClassName","getFirstClassName","extraClassName","getSecondClassName","id","className","Component","Navbar","state","algorithm","maze","selection","setState","selectAlgo","mazeName","selectMaze","changeSpeed","clearGrid","fire","generateMaze","algoName","href","onClick","window","location","reload","type","role","selectAlgorithm","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","nodes","node","push","getAllNodes","distance","length","sort","nodeA","nodeB","closestNode","pop","Infinity","isVisited","updateUnvisitedNeighbors","neighbors","unvisitedNeighbors","filter","neighbor","previousNode","calculatedManhattanDistance","currentNode","currentRow","currentCol","finishRow","finishCol","Math","abs","getNeighboringNodes","numRows","numCols","walls","MinHeap","array","nodePositionsInHeap","reduce","obj","i","heap","buildHeap","currentIdx","floor","siftDown","endIdx","childOneIdx","childTwoIdx","idxToSwap","estimatedDistanceToEnd","swap","parentIdx","isEmpty","siftUp","j","temp","getUnvisitedNeighbours","neighbours","neighbour","neighbourNotInUnvisitedNodes","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","dir","num","generateOddRandomNumber","addWall","slice","indexOf","max","randomNum","random","isStartFinish","tempWalls","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","ROW_NUM","innerHeight","COL_NUM","innerWidth","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","handleAlgoSelection","childData","setTimeout","console","log","handleMazeSelection","speed","changeNodeSize","setInitialGrid","mouseIsPressed","visualizing","mouse","toString","createNode","document","getElementById","clearPath","clearWall","newGrid","getNewGridWithWallToggled","currNode","nodeInShortestPathOrder","undefined","animateShortestPath","clearNodeStates","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","nodesToVisit","currentMinDistanceNode","remove","tentativeDistanceToNeighbor","containsNode","update","insert","Astar","path","reverse","reconstructPath","shift","unvisitedNeighbours","depthFirstSearch","NodesInPathOrder_DFS","breadthFirstSearch","NodesInPathOrder_BFS","animateVisitedNodes","randomMaze","animateWalls","createNewBoard","visualizeAlgorithm","visualizeMaze","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e053cf25.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n\t// Only re-render the node if the prop of node has change.\n\tshouldComponentUpdate(nextProps, nextState) {\n\t\treturn this.props.isWall !== nextProps.isWall;\n\t}\n\n\trender() {\n\t\t// Pass in the node type from props\n\t\tconst {\n\t\t\tcol,\n\t\t\trow,\n\t\t\tnodeSize,\n\t\t\tisFinish,\n\t\t\tisStart,\n\t\t\tisWall,\n\t\t\tonMouseDown,\n\t\t\tonMouseEnter,\n\t\t\tonMouseUp,\n\t\t} = this.props;\n\n\t\t// Return the correct class name for each node\n\t\tfunction getSecondClassName(isFinish, isStart, isWall) {\n\t\t\tif (isFinish) {\n\t\t\t\treturn \"node-finish\";\n\t\t\t} else if (isStart) {\n\t\t\t\treturn \"node-start\";\n\t\t\t} else if (isWall) {\n\t\t\t\treturn \"node-wall\";\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\tfunction getFirstClassName(nodeSize) {\n\t\t\tif (nodeSize === \"grand\") {\n\t\t\t\treturn \"node-grand\";\n\t\t\t} else {\n\t\t\t\treturn \"node\";\n\t\t\t}\n\t\t}\n\n\t\tconst nodeClassName = getFirstClassName(nodeSize);\n\t\tconst extraClassName = getSecondClassName(isFinish, isStart, isWall);\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tid={`node-${row}-${col}`}\n\t\t\t\tclassName={`${nodeClassName} ${extraClassName}`}\n\t\t\t\tonMouseUp={() => onMouseUp()}\n\t\t\t\tonMouseEnter={() => onMouseEnter(row, col)}\n\t\t\t\tonMouseDown={() => onMouseDown(row, col)}></div>\n\t\t);\n\t}\n}\n","import React, { Component } from \"react\";\nimport \"jquery/dist/jquery.min.js\";\nimport \"bootstrap/dist/js/bootstrap.min.js\"; // This ensure the dropdown works correctly\n// import \"bootstrap/dist/css/bootstrap.min.css\";\n// import \"bootstrap/dist/css/bootstrap.min.css\";\n// import Popper from \"popper.js\";\nimport \"bootswatch/dist/lux/bootstrap.min.css\";\nimport \"./navbar.css\";\n\nexport default class Navbar extends Component {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.state = {\n\t\t\talgorithm: \"Dijkstra\",\n\t\t\tmaze: \"Random\",\n\t\t};\n\t}\n\n\tselectAlgorithm(selection) {\n\t\tthis.setState({ algorithm: selection });\n\t\tthis.props.selectAlgo(selection);\n\t}\n\n\tselectMaze(selection) {\n\t\tconst mazeName =\n\t\t\tselection === \"randomMaze\"\n\t\t\t\t? \"Random\"\n\t\t\t\t: selection === \"recursiveDivision\"\n\t\t\t\t? \"Recursive\"\n\t\t\t\t: \"Vertical\";\n\n\t\tthis.setState({ maze: mazeName });\n\t\tthis.props.selectMaze(selection);\n\t}\n\n\tchangeSpeed(selection) {\n\t\tthis.props.changeSpeed(selection);\n\t}\n\n\tnodeSize(selection) {\n\t\tthis.props.nodeSize(selection);\n\t}\n\n\trender() {\n\t\tconst { clearGrid, fire, generateMaze } = this.props;\n\n\t\tconst algoName = this.state.algorithm;\n\t\tconst mazeName = this.state.maze;\n\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<nav className=\"navbar navbar-expand-lg navbar-dark bg-primary\">\n\t\t\t\t\t<div className=\"container-fluid\">\n\t\t\t\t\t\t<a\n\t\t\t\t\t\t\tclassName=\"navbar-brand\"\n\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\tonClick={() => window.location.reload()}>\n\t\t\t\t\t\t\tKev's Mazer\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclassName=\"navbar-toggler\"\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tdata-bs-toggle=\"collapse\"\n\t\t\t\t\t\t\tdata-bs-target=\"#navbarColor01\"\n\t\t\t\t\t\t\taria-controls=\"navbarColor01\"\n\t\t\t\t\t\t\taria-expanded=\"false\"\n\t\t\t\t\t\t\taria-label=\"Toggle navigation\">\n\t\t\t\t\t\t\t<span className=\"navbar-toggler-icon\"></span>\n\t\t\t\t\t\t</button>\n\n\t\t\t\t\t\t<div className=\"collapse navbar-collapse\" id=\"navbarColor01\">\n\t\t\t\t\t\t\t<ul className=\"navbar-nav me-auto\">\n\t\t\t\t\t\t\t\t{/* Select Algorithms */}\n\t\t\t\t\t\t\t\t<li className=\"nav-item dropdown\">\n\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\tclassName=\"nav-link dropdown-toggle\"\n\t\t\t\t\t\t\t\t\t\tdata-bs-toggle=\"dropdown\"\n\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\t\t\taria-haspopup=\"true\"\n\t\t\t\t\t\t\t\t\t\taria-expanded=\"false\">\n\t\t\t\t\t\t\t\t\t\tSelect Algorithms\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t<div className=\"dropdown-menu\">\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.selectAlgorithm(\"Dijkstra\")}>\n\t\t\t\t\t\t\t\t\t\t\tDijkstra's Algorithm\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.selectAlgorithm(\"A*\")}>\n\t\t\t\t\t\t\t\t\t\t\tA Star Algorithm\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.selectAlgorithm(\"DFS\")}>\n\t\t\t\t\t\t\t\t\t\t\tDepth First Search (DFS)\n\t\t\t\t\t\t\t\t\t\t</a>\n\n\t\t\t\t\t\t\t\t\t\t{/* <div className=\"dropdown-divider\"></div> */}\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.selectAlgorithm(\"BFS\")}>\n\t\t\t\t\t\t\t\t\t\t\tBreath First Search (BFS)\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</li>\n\n\t\t\t\t\t\t\t\t{/* Select Maze */}\n\t\t\t\t\t\t\t\t<li className=\"nav-item dropdown\">\n\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\tclassName=\"nav-link dropdown-toggle\"\n\t\t\t\t\t\t\t\t\t\tdata-bs-toggle=\"dropdown\"\n\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\t\t\taria-haspopup=\"true\"\n\t\t\t\t\t\t\t\t\t\taria-expanded=\"false\">\n\t\t\t\t\t\t\t\t\t\tMaze Generator\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t<div className=\"dropdown-menu\">\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.selectMaze(\"randomMaze\")}>\n\t\t\t\t\t\t\t\t\t\t\tRandom Maze\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.selectMaze(\"recursiveDivision\")}>\n\t\t\t\t\t\t\t\t\t\t\tRecursive Division Maze\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.selectMaze(\"vertical\")}>\n\t\t\t\t\t\t\t\t\t\t\tVertical Maze\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</li>\n\n\t\t\t\t\t\t\t\t{/* Change Speed */}\n\t\t\t\t\t\t\t\t<li className=\"nav-item dropdown\">\n\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\tclassName=\"nav-link dropdown-toggle\"\n\t\t\t\t\t\t\t\t\t\tdata-bs-toggle=\"dropdown\"\n\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\t\t\taria-haspopup=\"true\"\n\t\t\t\t\t\t\t\t\t\taria-expanded=\"false\">\n\t\t\t\t\t\t\t\t\t\tChange Visualize Speed\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t<div className=\"dropdown-menu\">\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.changeSpeed(30)}>\n\t\t\t\t\t\t\t\t\t\t\tSlow\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.changeSpeed(15)}>\n\t\t\t\t\t\t\t\t\t\t\tNormal\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.changeSpeed(2)}>\n\t\t\t\t\t\t\t\t\t\t\tFast\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t{/* Change grid size */}\n\t\t\t\t\t\t\t\t{/* <li className=\"nav-item dropdown\">\n\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\tclassName=\"nav-link dropdown-toggle\"\n\t\t\t\t\t\t\t\t\t\tdata-bs-toggle=\"dropdown\"\n\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\t\t\taria-haspopup=\"true\"\n\t\t\t\t\t\t\t\t\t\taria-expanded=\"false\">\n\t\t\t\t\t\t\t\t\t\tGrid Size\n\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t<div className=\"dropdown-menu\">\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.nodeSize(\"normal\")}>\n\t\t\t\t\t\t\t\t\t\t\tNormal\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"dropdown-item\"\n\t\t\t\t\t\t\t\t\t\t\tdata-toggle=\"tab\"\n\t\t\t\t\t\t\t\t\t\t\thref=\"/#\"\n\t\t\t\t\t\t\t\t\t\t\tonClick={() => this.nodeSize(\"grand\")}>\n\t\t\t\t\t\t\t\t\t\t\tGrand\n\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</li> */}\n\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</nav>\n\t\t\t\t<div className=\"fireBtn\">\n\t\t\t\t\t<h1>Pathfinding Visualizer</h1>\n\t\t\t\t\t<button className=\"bg-info\" onClick={() => generateMaze()}>\n\t\t\t\t\t\tGenerate {mazeName} Maze\n\t\t\t\t\t</button>\n\t\t\t\t\t<button\n\t\t\t\t\t\tclassName=\"bg-warning\"\n\t\t\t\t\t\t// Change later\n\t\t\t\t\t\tonClick={() => fire()}>\n\t\t\t\t\t\tVisualize {algoName} Algorithm\n\t\t\t\t\t</button>\n\t\t\t\t\t<button className=\"bg-dark text-light\" onClick={() => clearGrid()}>\n\t\t\t\t\t\tClear Board\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n","// Implementation of dijkstra's algorithm\n// Returns all the visited nodes, and nodes point back to their previous node\n// allowing us to compute the shortest path by backtracking from the finish node.\n// Typically, we use a minHeap.\n\nexport function dijkstra(grid, startNode, finishNode) {\n\tconst visitedNodesInOrder = [];\n\tconst unvisitedNodes = getAllNodes(grid); // Note that unvisitedNode contains all nodes\n\tstartNode.distance = 0;\n\n\t// Keep iterating until there are no more unvisited nodes\n\twhile (!!unvisitedNodes.length) {\n\t\t// Reverse sort by shortest distance and get closest node\n\t\tunvisitedNodes.sort((nodeA, nodeB) => nodeB.distance - nodeA.distance);\n\t\tconst closestNode = unvisitedNodes.pop();\n\n\t\t// If we encounter a wall, continue\n\t\tif (closestNode.isWall) continue;\n\n\t\t// Cases where we return the visitedNodesInOrder\n\t\tif (closestNode.distance === Infinity || closestNode === finishNode) {\n\t\t\treturn visitedNodesInOrder;\n\t\t}\n\t\tclosestNode.isVisited = true;\n\t\tvisitedNodesInOrder.push(closestNode);\n\n\t\t// Update the unvisited neighbors\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\n\t}\n}\n\n// Unpack two dimensional grid into one dimensional nodes\nfunction getAllNodes(grid) {\n\tconst nodes = [];\n\tfor (const row of grid) {\n\t\tfor (const node of row) {\n\t\t\tnodes.push(node);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\t// Get all neighbors and filters out the visited nodes\n\tconst neighbors = [];\n\tconst { col, row } = node;\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\tconst unvisitedNeighbors = neighbors.filter(\n\t\t(neighbor) => !neighbor.isVisited\n\t);\n\n\t// Update the distance of neighbor nodes\n\tfor (const neighbor of unvisitedNeighbors) {\n\t\tneighbor.distance = node.distance + 1;\n\t\tneighbor.previousNode = node;\n\t}\n}\n// Backtrack from finish node to start node to get the shortest path\nexport function getNodesInShortestPathOrder(finishNode, startNode) {\n\tconst nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","export function Astar(grid, startNode, finishNode) {\n\t// Initial set up\n\tstartNode.distance = 0;\n\tstartNode.estimatedDistanceToEnd = calculatedManhattanDistance(\n\t\tstartNode,\n\t\tfinishNode\n\t);\n\tconst nodesToVisit = new MinHeap([startNode]);\n\tconst visitedNodesInOrder = [];\n\n\t// Computer shortest path\n\twhile (!nodesToVisit.isEmpty()) {\n\t\tconst currentMinDistanceNode = nodesToVisit.remove();\n\t\tif (currentMinDistanceNode === finishNode) break;\n\t\tvisitedNodesInOrder.push(currentMinDistanceNode);\n\n\t\tconst neighbors = getNeighboringNodes(currentMinDistanceNode, grid);\n\n\t\tfor (const neighbor of neighbors) {\n\t\t\tif (neighbor.isWall) continue; // neighbor is a wall\n\t\t\t// visitedNodesInOrder.push(neighbor);\n\n\t\t\tconst tentativeDistanceToNeighbor =\n\t\t\t\tcurrentMinDistanceNode.distance + 1;\n\n\t\t\tif (tentativeDistanceToNeighbor >= neighbor.distance) continue; // already has shorter path\n\n\t\t\tneighbor.previousNode = currentMinDistanceNode;\n\t\t\tneighbor.distance = tentativeDistanceToNeighbor;\n\t\t\tneighbor.estimatedDistanceToEnd =\n\t\t\t\ttentativeDistanceToNeighbor +\n\t\t\t\tcalculatedManhattanDistance(neighbor, finishNode);\n\n\t\t\tif (!nodesToVisit.containsNode(neighbor)) {\n\t\t\t\tnodesToVisit.insert(neighbor);\n\t\t\t} else {\n\t\t\t\tnodesToVisit.update(neighbor);\n\t\t\t}\n\t\t}\n\t}\n\treturn visitedNodesInOrder;\n}\n\nexport function reconstructPath(finishNode) {\n\tif (finishNode.previousNode == null) {\n\t\treturn [];\n\t}\n\tlet currentNode = finishNode;\n\tconst path = [];\n\n\twhile (currentNode != null) {\n\t\tpath.push(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\n\tpath.reverse();\n\treturn path;\n}\n\nfunction calculatedManhattanDistance(currentNode, finishNode) {\n\tconst currentRow = currentNode.row;\n\tconst currentCol = currentNode.col;\n\tconst finishRow = finishNode.row;\n\tconst finishCol = finishNode.col;\n\treturn Math.abs(currentRow - finishRow) + Math.abs(currentCol - finishCol);\n}\n\nfunction getNeighboringNodes(node, grid) {\n\tconst neighbors = [];\n\tconst numRows = grid.length;\n\tconst numCols = grid[0].length;\n\tconst row = node.row;\n\tconst col = node.col;\n\n\t// Down\n\tif (row < numRows - 1) {\n\t\tneighbors.push(grid[row + 1][col]);\n\t}\n\n\t// Up\n\tif (row > 0) {\n\t\tneighbors.push(grid[row - 1][col]);\n\t}\n\n\t// Right\n\tif (col < numCols - 1) {\n\t\tneighbors.push(grid[row][col + 1]);\n\t}\n\n\t// Left\n\tif (col > 0) {\n\t\tneighbors.push(grid[row][col - 1]);\n\t}\n\n\treturn neighbors;\n}\n\n// ------------------------------------------------------------------------\n\nclass MinHeap {\n\tconstructor(array) {\n\t\t// Holds the position in heap that each node is at\n\t\tthis.nodePositionsInHeap = array.reduce((obj, node, i) => {\n\t\t\tobj[node.id] = i;\n\t\t\treturn obj;\n\t\t}, {});\n\t\tthis.heap = this.buildHeap(array);\n\t}\n\n\tisEmpty() {\n\t\treturn this.heap.length === 0;\n\t}\n\n\t// O(n) time | O(1) space\n\tbuildHeap(array) {\n\t\tconst firstParentIdx = Math.floor((array.length - 2) / 2);\n\t\tfor (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n\t\t\tthis.siftDown(currentIdx, array.length - 1, array);\n\t\t}\n\t\treturn array;\n\t}\n\n\t// O(log(n)) time | O(1) space\n\tsiftDown(currentIdx, endIdx, heap) {\n\t\tlet childOneIdx = currentIdx * 2 + 1;\n\t\twhile (childOneIdx <= endIdx) {\n\t\t\tconst childTwoIdx =\n\t\t\t\tcurrentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n\t\t\tlet idxToSwap;\n\t\t\tif (\n\t\t\t\tchildTwoIdx !== -1 &&\n\t\t\t\theap[childTwoIdx].estimatedDistanceToEnd <\n\t\t\t\t\theap[childOneIdx].estimatedDistanceToEnd\n\t\t\t) {\n\t\t\t\tidxToSwap = childTwoIdx;\n\t\t\t} else {\n\t\t\t\tidxToSwap = childOneIdx;\n\t\t\t}\n\t\t\tif (\n\t\t\t\theap[idxToSwap].estimatedDistanceToEnd <\n\t\t\t\theap[currentIdx].estimatedDistanceToEnd\n\t\t\t) {\n\t\t\t\tthis.swap(currentIdx, idxToSwap, heap);\n\t\t\t\tcurrentIdx = idxToSwap;\n\t\t\t\tchildOneIdx = currentIdx * 2 + 1;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// O(log(n)) time | O(1) space\n\tsiftUp(currentIdx, heap) {\n\t\tlet parentIdx = Math.floor((currentIdx - 1) / 2);\n\t\twhile (\n\t\t\tcurrentIdx > 0 &&\n\t\t\theap[currentIdx].estimatedDistanceToEnd <\n\t\t\t\theap[parentIdx].estimatedDistanceToEnd\n\t\t) {\n\t\t\tthis.swap(currentIdx, parentIdx, heap);\n\t\t\tcurrentIdx = parentIdx;\n\t\t\tparentIdx = Math.floor((currentIdx - 1) / 2);\n\t\t}\n\t}\n\n\t// O(log(n)) time | O(1) space\n\tremove() {\n\t\tif (this.isEmpty()) return;\n\n\t\tthis.swap(0, this.heap.length - 1, this.heap);\n\t\tconst node = this.heap.pop();\n\t\tdelete this.nodePositionsInHeap[node.id];\n\t\tthis.siftDown(0, this.heap.length - 1, this.heap);\n\t\treturn node;\n\t}\n\n\t// O(log(n)) time | O(1) space\n\tinsert(node) {\n\t\tthis.heap.push(node);\n\t\tthis.nodePositionsInHeap[node.id] = this.heap.length - 1;\n\t\tthis.siftUp(this.heap.length - 1, this.heap);\n\t}\n\n\tswap(i, j, heap) {\n\t\tthis.nodePositionsInHeap[this.heap[i].id] = j;\n\t\tthis.nodePositionsInHeap[this.heap[j].id] = i;\n\t\tconst temp = heap[j];\n\t\theap[j] = heap[i];\n\t\theap[i] = temp;\n\t}\n\n\tcontainsNode(node) {\n\t\treturn node.id in this.nodePositionsInHeap;\n\t}\n\n\tupdate(node) {\n\t\tthis.siftUp(this.nodePositionsInHeap[node.id], this.heap);\n\t}\n}\n","let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n\tif (!startNode || !finishNode || startNode === finishNode) {\n\t\treturn false;\n\t}\n\tlet vertical = range(grid[0].length);\n\tlet horizontal = range(grid.length);\n\twalls = [];\n\tgetRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n\tfor (let i = 0; i < walls.length; i++) {\n\t\tconst currentNode = grid[walls[i][0]][walls[i][1]];\n\t\twalls[i] = currentNode;\n\t}\n\treturn walls;\n}\n\nfunction range(len) {\n\tlet result = [];\n\tfor (let i = 0; i < len; i++) {\n\t\tresult.push(i);\n\t}\n\treturn result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n\tif (vertical.length < 2 || horizontal.length < 2) {\n\t\treturn;\n\t}\n\tlet dir;\n\tlet num;\n\tif (vertical.length > horizontal.length) {\n\t\tdir = 0;\n\t\tnum = generateOddRandomNumber(vertical);\n\t}\n\tif (vertical.length <= horizontal.length) {\n\t\tdir = 1;\n\t\tnum = generateOddRandomNumber(horizontal);\n\t}\n\n\tif (dir === 0) {\n\t\taddWall(dir, num, vertical, horizontal, startNode, finishNode);\n\t\tgetRecursiveWalls(\n\t\t\tvertical.slice(0, vertical.indexOf(num)),\n\t\t\thorizontal,\n\t\t\tgrid,\n\t\t\tstartNode,\n\t\t\tfinishNode\n\t\t);\n\t\tgetRecursiveWalls(\n\t\t\tvertical.slice(vertical.indexOf(num) + 1),\n\t\t\thorizontal,\n\t\t\tgrid,\n\t\t\tstartNode,\n\t\t\tfinishNode\n\t\t);\n\t} else {\n\t\taddWall(dir, num, vertical, horizontal, startNode, finishNode);\n\t\tgetRecursiveWalls(\n\t\t\tvertical,\n\t\t\thorizontal.slice(0, horizontal.indexOf(num)),\n\t\t\tgrid,\n\t\t\tstartNode,\n\t\t\tfinishNode\n\t\t);\n\t\tgetRecursiveWalls(\n\t\t\tvertical,\n\t\t\thorizontal.slice(horizontal.indexOf(num) + 1),\n\t\t\tgrid,\n\t\t\tstartNode,\n\t\t\tfinishNode\n\t\t);\n\t}\n}\n\nfunction generateOddRandomNumber(array) {\n\tlet max = array.length - 1;\n\tlet randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\tif (randomNum % 2 === 0) {\n\t\tif (randomNum === max) {\n\t\t\trandomNum -= 1;\n\t\t} else {\n\t\t\trandomNum += 1;\n\t\t}\n\t}\n\treturn array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n\tlet isStartFinish = false;\n\tlet tempWalls = [];\n\tif (dir === 0) {\n\t\tif (horizontal.length === 2) return;\n\t\tfor (let temp of horizontal) {\n\t\t\tif (\n\t\t\t\t(temp === startNode.row && num === startNode.col) ||\n\t\t\t\t(temp === finishNode.row && num === finishNode.col)\n\t\t\t) {\n\t\t\t\tisStartFinish = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttempWalls.push([temp, num]);\n\t\t}\n\t} else {\n\t\tif (vertical.length === 2) return;\n\t\tfor (let temp of vertical) {\n\t\t\tif (\n\t\t\t\t(num === startNode.row && temp === startNode.col) ||\n\t\t\t\t(num === finishNode.row && temp === finishNode.col)\n\t\t\t) {\n\t\t\t\tisStartFinish = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttempWalls.push([num, temp]);\n\t\t}\n\t}\n\tif (!isStartFinish) {\n\t\ttempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n\t}\n\tfor (let wall of tempWalls) {\n\t\twalls.push(wall);\n\t}\n}\n\nfunction generateRandomNumber(max) {\n\tlet randomNum = Math.floor(Math.random() * (max / 2)) + Math.floor(Math.random() * (max / 2));\n\tif (randomNum % 2 !== 0) {\n\t\tif (randomNum === max) {\n\t\t\trandomNum -= 1;\n\t\t} else {\n\t\t\trandomNum += 1;\n\t\t}\n\t}\n\treturn randomNum;\n}\n","let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n\tlet vertical = range(grid[0].length);\n\tlet horizontal = range(grid.length);\n\twalls = [];\n\tgetVerticalWalls(vertical, horizontal, startNode, finishNode);\n\tfor (let i = 0; i < walls.length; i++) {\n\t\tconst currentNode = grid[walls[i][0]][walls[i][1]];\n\t\twalls[i] = currentNode;\n\t}\n\treturn walls;\n}\n\nfunction range(len) {\n\tlet result = [];\n\tfor (let i = 0; i < len; i++) {\n\t\tresult.push(i);\n\t}\n\treturn result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n\tif (vertical.length < 2) {\n\t\treturn;\n\t}\n\n\tlet choice = Math.floor(Math.random() * 2);\n\tfor (let num of vertical) {\n\t\tif (choice === 0 && num % 2 !== 0) {\n\t\t\taddWall(num, horizontal, startNode, finishNode);\n\t\t}\n\t\tif (choice === 1 && num % 2 === 0) {\n\t\t\taddWall(num, horizontal, startNode, finishNode);\n\t\t}\n\t}\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n\tlet isStartFinish = false;\n\tlet tempWalls = [];\n\tfor (let temp of horizontal) {\n\t\tif (\n\t\t\t(temp === startNode.row && num === startNode.col) ||\n\t\t\t(temp === finishNode.row && num === finishNode.col)\n\t\t) {\n\t\t\tisStartFinish = true;\n\t\t\tcontinue;\n\t\t}\n\t\ttempWalls.push([temp, num]);\n\t}\n\tif (!isStartFinish) {\n\t\ttempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n\t}\n\tfor (let wall of tempWalls) {\n\t\twalls.push(wall);\n\t}\n}\n","export function depthFirstSearch(grid, startNode, finishNode) {\n\t// Initial setup\n\tlet unvisitedNodes = [];\n\tlet visitedNodesInOrder = [];\n\tunvisitedNodes.push(startNode);\n\n\t// BFS call\n\twhile (unvisitedNodes.length !== 0) {\n\t\tlet closestNode = unvisitedNodes.shift();\n\t\tif (closestNode.isWall) continue;\n\t\tif (closestNode === finishNode) break;\n\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tclosestNode.isVisited = true;\n\n\t\t// Get neighbors\n\t\tlet unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n\t\tfor (let neighbor of unvisitedNeighbours) {\n\t\t\tneighbor.previousNode = closestNode;\n\t\t\tunvisitedNodes.unshift(neighbor);\n\t\t}\n\t}\n\treturn visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n\tlet neighbours = [];\n\tlet { row, col } = node;\n\tif (col !== 0) neighbours.push(grid[row][col - 1]);\n\tif (row !== 0) neighbours.push(grid[row - 1][col]);\n\tif (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\tif (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n\treturn neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nexport function NodesInPathOrder_DFS(finishNode) {\n\tlet nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","export function breadthFirstSearch(grid, startNode, finishNode) {\n\t// Initial Setup\n\tlet unvisitedNodes = [];\n\tlet visitedNodesInOrder = [];\n\tunvisitedNodes.push(startNode);\n\n\twhile (unvisitedNodes.length !== 0) {\n\t\tlet closestNode = unvisitedNodes.shift();\n\n\t\tif (closestNode.isWall) continue;\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\n\n\t\tvisitedNodesInOrder.push(closestNode);\n\t\tclosestNode.isVisited = true;\n\n\t\t// Get neighbours\n\t\tlet unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n\t\tfor (let neighbor of unvisitedNeighbours) {\n\t\t\tneighbor.previousNode = closestNode;\n\t\t\tif (neighbourNotInUnvisitedNodes(neighbor, unvisitedNodes)) {\n\t\t\t\tunvisitedNodes.push(neighbor);\n\t\t\t}\n\t\t}\n\t}\n\treturn visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n\tlet neighbours = [];\n\tlet { row, col } = node;\n\tif (row !== 0) neighbours.push(grid[row - 1][col]);\n\tif (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n\tif (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n\tif (col !== 0) neighbours.push(grid[row][col - 1]);\n\treturn neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n\tfor (let node of unvisitedNodes) {\n\t\tif (node.row === neighbour.row && node.col === neighbour.col) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nexport function NodesInPathOrder_BFS(finishNode) {\n\tlet nodesInShortestPathOrder = [];\n\tlet currentNode = finishNode;\n\twhile (currentNode !== null) {\n\t\tnodesInShortestPathOrder.unshift(currentNode);\n\t\tcurrentNode = currentNode.previousNode;\n\t}\n\treturn nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"bootswatch/dist/lux/bootstrap.min.css\";\nimport \"./PathfindingVisualizer.css\";\nimport Navbar from \"./navbar\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../Algorithms/dijkstra\";\nimport { Astar, reconstructPath } from \"../Algorithms/Astar\";\nimport { randomMaze } from \"../Algorithms/randomMaze\";\nimport { depthFirstSearch, NodesInPathOrder_DFS } from \"../Algorithms/DFS\";\nimport { breadthFirstSearch, NodesInPathOrder_BFS } from \"../Algorithms/BFS\";\nimport { recursiveDivisionMaze } from \"../Algorithms/recursiveDivision\";\nimport { verticalMaze } from \"../Algorithms/verticalMaze\";\n\nvar ROW_NUM = Math.floor((window.innerHeight * 0.75) / 25);\nvar COL_NUM = Math.floor(window.innerWidth / 25);\n\nvar START_NODE_ROW = 6;\nvar START_NODE_COL = 7;\nvar FINISH_NODE_ROW = ROW_NUM - 5;\nvar FINISH_NODE_COL = COL_NUM - 5;\n\nexport default class PathfindingVisualizer extends Component {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.state = {\n\t\t\tgrid: [],\n\t\t\tmouseIsPressed: false,\n\t\t\tvisualizing: false,\n\t\t\talgorithm: \"Dijkstra\",\n\t\t\tmaze: \"randomMaze\",\n\t\t\tspeed: 2,\n\t\t\tnodeSize: \"normal\",\n\t\t};\n\t}\n\n\tshouldComponentUpdate(nextProps, nextState) {\n\t\treturn this.state.mouseIsPressed !== nextState.mouse;\n\t}\n\n\t// Create a single node with specified column and row\n\tcreateNode(col, row) {\n\t\treturn {\n\t\t\tcol,\n\t\t\trow,\n\t\t\tnodeSize: this.state.nodeSize,\n\t\t\tisStart: row === START_NODE_ROW && col === START_NODE_COL,\n\t\t\tisFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n\t\t\tdistance: Infinity,\n\t\t\tisVisited: false,\n\t\t\tisWall: false,\n\t\t\tpreviousNode: null,\n\t\t\testimatedDistanceToEnd: Infinity,\n\t\t\tid: row.toString() + \"-\" + col.toString(),\n\t\t};\n\t}\n\n\tsetInitialGrid() {\n\t\tconst grid = [];\n\t\tfor (let row = 0; row < ROW_NUM; row++) {\n\t\t\tconst currentRow = [];\n\t\t\tfor (let col = 0; col < COL_NUM; col++) {\n\t\t\t\tcurrentRow.push(this.createNode(col, row));\n\t\t\t}\n\t\t\tgrid.push(currentRow);\n\t\t}\n\t\tthis.setState({ grid });\n\t}\n\n\t// Initialize the grid to the DOM\n\tcomponentDidMount() {\n\t\tthis.setInitialGrid();\n\t}\n\n\tclearPath() {\n\t\tif (this.state.visualizing === false) {\n\t\t\tfor (let row = 0; row < ROW_NUM; row++) {\n\t\t\t\tfor (let col = 0; col < COL_NUM; col++) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tdocument.getElementById(`node-${row}-${col}`).className ===\n\t\t\t\t\t\t\t\"node node-shortest-path\" ||\n\t\t\t\t\t\tdocument.getElementById(`node-${row}-${col}`).className ===\n\t\t\t\t\t\t\t\"node node-visited\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tdocument.getElementById(`node-${row}-${col}`).className = \"node\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclearWall() {\n\t\tif (this.state.visualizing === false) {\n\t\t\tfor (let row = 0; row < ROW_NUM; row++) {\n\t\t\t\tfor (let col = 0; col < COL_NUM; col++) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tdocument.getElementById(`node-${row}-${col}`).className === \"node node-wall\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tdocument.getElementById(`node-${row}-${col}`).className = \"node\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclearGrid() {\n\t\tif (this.state.visualizing === false) {\n\t\t\tthis.setInitialGrid();\n\t\t\tthis.clearPath();\n\t\t\tthis.clearWall();\n\t\t}\n\t}\n\n\tcreateNewBoard() {\n\t\tconst grid = [];\n\t\tfor (let row = 0; row < ROW_NUM; row++) {\n\t\t\tconst currentRow = [];\n\t\t\tfor (let col = 0; col < COL_NUM; col++) {\n\t\t\t\tcurrentRow.push(this.createNode(col, row));\n\t\t\t}\n\t\t\tgrid.push(currentRow);\n\t\t}\n\t\treturn grid;\n\t}\n\n\t// Handle mouse events for wall setting\n\thandleMouseDown(row, col) {\n\t\tif (this.state.visualizing === false) {\n\t\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n\t\t\tthis.setState({ grid: newGrid, mouseIsPressed: true });\n\t\t}\n\t}\n\n\thandleMouseEnter(row, col) {\n\t\tif (this.state.mouseIsPressed && this.state.visualizing === false) {\n\t\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n\t\t\tthis.setState({ grid: newGrid, mouseIsPressed: true });\n\t\t}\n\t}\n\n\thandleMouseUp() {\n\t\tthis.setState({ mouseIsPressed: false });\n\t}\n\n\t// Clear nodes states except wall\n\tclearNodeStates() {\n\t\tconst grid = [];\n\t\tfor (let row = 0; row < ROW_NUM; row++) {\n\t\t\tconst currentRow = [];\n\t\t\tfor (let col = 0; col < COL_NUM; col++) {\n\t\t\t\tconst currNode = this.createNode(col, row);\n\t\t\t\tconst oldNode = this.state.grid[row][col];\n\t\t\t\tif (oldNode.isWall) {\n\t\t\t\t\tcurrNode.isWall = true;\n\t\t\t\t}\n\t\t\t\tcurrentRow.push(currNode);\n\t\t\t}\n\t\t\tgrid.push(currentRow);\n\t\t}\n\t\tthis.setState({ grid });\n\t}\n\n\t// visualizeAlgorithm -> animateVisitedNodes -> animateShortestPath\n\tanimateVisitedNodes(visitedNodesInOrder, nodeInShortestPathOrder) {\n\t\tif (visitedNodesInOrder === undefined || nodeInShortestPathOrder === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tconst speed = this.state.speed;\n\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\n\t\t\t// Animate the shortest path after animating dijkstra\n\t\t\tif (i === visitedNodesInOrder.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.animateShortestPath(nodeInShortestPathOrder);\n\t\t\t\t}, speed * i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = visitedNodesInOrder[i];\n\t\t\t\tif (!node.isStart && !node.isFinish) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node node-visited\";\n\t\t\t\t}\n\t\t\t}, speed * i);\n\t\t}\n\t}\n\n\t// Part of visualizeAlgorithm\n\tanimateShortestPath(nodeInShortestPathOrder) {\n\t\tfor (let i = 0; i < nodeInShortestPathOrder.length; i++) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = nodeInShortestPathOrder[i];\n\t\t\t\tif (!node.isStart && !node.isFinish) {\n\t\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\t\"node node-shortest-path\";\n\t\t\t\t}\n\t\t\t}, 30 * i);\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\tthis.setState({ visualizing: false });\n\t\t}, 30 * nodeInShortestPathOrder.length);\n\t}\n\n\tvisualizeAlgorithm() {\n\t\tif (this.state.visualizing === true) return;\n\t\tthis.clearPath();\n\t\tthis.clearNodeStates();\n\t\tthis.setState({ visualizing: true });\n\t\tconst grid = this.state.grid;\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COL];\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n\t\tlet visitedNodesInOrder;\n\t\tlet nodeInShortestPathOrder;\n\n\t\tif (this.state.algorithm === \"Dijkstra\") {\n\t\t\tvisitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n\t\t\tnodeInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\t\t} else if (this.state.algorithm === \"A*\") {\n\t\t\tvisitedNodesInOrder = Astar(grid, startNode, finishNode);\n\t\t\tnodeInShortestPathOrder = reconstructPath(finishNode);\n\t\t} else if (this.state.algorithm === \"DFS\") {\n\t\t\tvisitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n\t\t\tnodeInShortestPathOrder = NodesInPathOrder_DFS(finishNode);\n\t\t} else if (this.state.algorithm === \"BFS\") {\n\t\t\tvisitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\n\t\t\tnodeInShortestPathOrder = NodesInPathOrder_BFS(finishNode);\n\t\t}\n\t\tthis.animateVisitedNodes(visitedNodesInOrder, nodeInShortestPathOrder);\n\t}\n\n\t// Visualize Maze generation\n\tvisualizeMaze() {\n\t\tif (this.state.visualizing === true) return;\n\t\tthis.clearGrid();\n\t\tthis.setState({ visualizing: true });\n\n\t\tconst grid = this.state.grid;\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COL];\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n\t\tlet walls;\n\n\t\tif (this.state.maze === \"randomMaze\") {\n\t\t\twalls = randomMaze(grid, startNode, finishNode);\n\t\t} else if (this.state.maze === \"recursiveDivision\") {\n\t\t\twalls = recursiveDivisionMaze(grid, startNode, finishNode);\n\t\t} else if (this.state.maze === \"vertical\") {\n\t\t\twalls = verticalMaze(grid, startNode, finishNode);\n\t\t}\n\n\t\tthis.animateWalls(walls);\n\t}\n\n\tanimateWalls(walls) {\n\t\tif (walls === undefined) return;\n\t\tconst grid = this.createNewBoard();\n\n\t\tfor (let i = 0; i < walls.length; i++) {\n\t\t\t// Animate the shortest path after animating dijkstra\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = walls[i];\n\t\t\t\tgrid[node.row][node.col].isWall = true;\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t\"node node-wall\";\n\t\t\t}, 5 * i);\n\t\t}\n\t\tsetTimeout(() => {\n\t\t\tthis.setState({ visualizing: false, grid });\n\t\t}, 5 * walls.length);\n\t}\n\n\thandleAlgoSelection = (childData) => {\n\t\tthis.setState({ algorithm: childData });\n\t\t// testing\n\t\tsetTimeout(() => {\n\t\t\tconsole.log(this.state.algorithm);\n\t\t}, 1000);\n\t};\n\n\thandleMazeSelection = (childData) => {\n\t\tthis.setState({ maze: childData });\n\t};\n\n\tchangeSpeed = (childData) => {\n\t\tthis.setState({ speed: childData });\n\t};\n\n\t// NOT WORKING\n\tchangeNodeSize = (childData) => {\n\t\tconsole.log(childData);\n\t\tif (childData === \"grand\") {\n\t\t\tthis.setState({ nodeSize: \"grand\" });\n\t\t\tROW_NUM = Math.floor((window.innerHeight * 0.75) / 15);\n\t\t\tCOL_NUM = Math.floor(window.innerWidth / 15);\n\t\t\tSTART_NODE_ROW = 6;\n\t\t\tSTART_NODE_COL = 7;\n\t\t\tFINISH_NODE_ROW = ROW_NUM - 5;\n\t\t\tFINISH_NODE_COL = COL_NUM - 5;\n\t\t\tsetTimeout(() => {\n\t\t\t\tconsole.log(this.state.nodeSize);\n\t\t\t\tthis.setInitialGrid();\n\t\t\t}, 1000);\n\t\t}\n\t};\n\n\trender() {\n\t\tconst { grid, mouseIsPressed } = this.state;\n\t\treturn (\n\t\t\t<div className=\"main\">\n\t\t\t\t<div className=\"main-navigation\">\n\t\t\t\t\t<Navbar\n\t\t\t\t\t\tclearGrid={() => this.clearGrid()}\n\t\t\t\t\t\tselectAlgo={this.handleAlgoSelection}\n\t\t\t\t\t\tselectMaze={this.handleMazeSelection}\n\t\t\t\t\t\tchangeSpeed={this.changeSpeed}\n\t\t\t\t\t\t// nodeSize={this.changeNodeSize}\n\t\t\t\t\t\tfire={() => this.visualizeAlgorithm()}\n\t\t\t\t\t\tgenerateMaze={() => this.visualizeMaze()}></Navbar>\n\t\t\t\t</div>\n\n\t\t\t\t{/* Initialize the grid */}\n\t\t\t\t<div className=\"grid\">\n\t\t\t\t\t{grid.map((row, rowIdx) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={rowIdx} className=\"row-default\">\n\t\t\t\t\t\t\t\t{row.map((node, nodeIdx) => {\n\t\t\t\t\t\t\t\t\tconst { row, col, isFinish, isStart, isWall, nodeSize } = node;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\t// Pass in the props to Node component\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIdx}\n\t\t\t\t\t\t\t\t\t\t\tcol={col}\n\t\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\t\tnodeSize={nodeSize}\n\t\t\t\t\t\t\t\t\t\t\tisFinish={isFinish}\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t\t\t\t\tmouseIsPressed={mouseIsPressed}\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, col) =>\n\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseDown(row, col)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) =>\n\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseEnter(row, col)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.handleMouseUp()}></Node>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n\tconst newGrid = grid.slice();\n\tnewGrid[row][col].isWall = true;\n\treturn newGrid;\n};\n","export function randomMaze(grid, startNode, finishNode) {\n\tlet newGrid = [];\n\tfor (let row = 0; row < grid.length; row++) {\n\t\tfor (let col = 0; col < grid[0].length; col++) {\n\t\t\tconst currNode = grid[row][col];\n\t\t\tif (currNode === startNode || currNode === finishNode) continue;\n\t\t\tif (Math.random() < 0.33) {\n\t\t\t\tcurrNode.isWall = true;\n\t\t\t\tnewGrid.push(currNode);\n\t\t\t}\n\t\t}\n\t}\n\t// newGrid.sort(() => Math.random() - 0.5);\n\treturn newGrid;\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <PathfindingVisualizer></PathfindingVisualizer>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}